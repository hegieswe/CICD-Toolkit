#!/usr/bin/env python3
"""
CI Script - Docker Build & Push dengan output JSON untuk CD pipeline.

Usage:
    ci              # Build dan push image
    ci --info       # Tampilkan build info saja (alias: -i, --dry-run, -n)
"""
import json
import subprocess
import sys
from pathlib import Path

# --------------------------------------------------
# Constants
# --------------------------------------------------
DOCKER_ORG = "loyaltolpi"
BUILDER_NAME = "attest-builder"
PLATFORM = "linux/amd64"

# Colors
YELLOW = "\033[33m"
GREEN = "\033[32m"
RED = "\033[31m"
CYAN = "\033[36m"
RESET = "\033[0m"
BOLD = "\033[1m"
DIM = "\033[2m"

# Box Drawing Characters (Rounded)
class Box:
    TL = "‚ï≠"  # Top Left
    TR = "‚ïÆ"  # Top Right
    BL = "‚ï∞"  # Bottom Left
    BR = "‚ïØ"  # Bottom Right
    H  = "‚îÄ"  # Horizontal


# --------------------------------------------------
# Helper Functions
# --------------------------------------------------
def info(label: str, value: str, icon: str = "‚Ä¢") -> None:
    """Print formatted info line."""
    print(f" {icon} {label:<10}: {BOLD}{value}{RESET}")


def error(message: str) -> None:
    """Print error message and exit."""
    print(f"{RED}‚úñ Error: {message}{RESET}")
    sys.exit(1)


def success(message: str) -> None:
    """Print success message."""
    print(f"{GREEN}‚úî {message}{RESET}")


def run(cmd: list[str], silent: bool = False) -> None:
    """Run command with output."""
    if not silent:
        print(f"{YELLOW}‚ñ∂ {' '.join(cmd)}{RESET}")
    subprocess.run(cmd, check=True)


def git(*args: str) -> str:
    """Run git command and return output."""
    return subprocess.check_output(
        ["git", *args],
        stderr=subprocess.DEVNULL
    ).decode().strip()


def get_git_info() -> tuple[str, str]:
    """
    Get image tag and branch from git.
    Returns: (tag, branch)
    """
    try:
        # Check if on exact tag
        tag = git("describe", "--tags", "--exact-match")
        return tag, "production"
    except subprocess.CalledProcessError:
        # Use short commit hash as tag
        short_sha = git("rev-parse", "--short=7", "HEAD")
        branch = git("rev-parse", "--abbrev-ref", "HEAD")
        return short_sha, branch


def ensure_builder(name: str) -> None:
    """Ensure buildx builder exists and is active."""
    try:
        # Check if builder exists
        result = subprocess.run(
            ["docker", "buildx", "inspect", name],
            capture_output=True
        )
        if result.returncode == 0:
            run(["docker", "buildx", "use", name], silent=True)
        else:
            raise subprocess.CalledProcessError(1, "inspect")
    except subprocess.CalledProcessError:
        print(f"{CYAN}üì¶ Creating builder '{name}'...{RESET}")
        run(["docker", "buildx", "create", "--name", name, "--use"])


def load_config(config_path: Path) -> dict:
    """Load and validate config file."""
    if not config_path.exists():
        error(f"Config tidak ditemukan: {config_path}")
    
    with config_path.open() as f:
        config = json.load(f)
    
    # Validate required fields
    required_fields = ["IMAGE", "PROJECT"]
    missing = [f for f in required_fields if not config.get(f)]
    if missing:
        error(f"Field wajib tidak ditemukan di cicd.json: {', '.join(missing)}")
    
    return config


# --------------------------------------------------
# Main
# --------------------------------------------------
def main() -> None:
    # Parse args - info mode: just show build info without building
    info_only = any(arg in sys.argv for arg in ["--dry-run", "-n", "--info", "-i"])
    
    # Paths
    repo_dir = Path.cwd()
    config_file = repo_dir / "cicd" / "cicd.json"
    output_file = repo_dir / "build-output.json"
    
    # Load config
    config = load_config(config_file)
    image_name = config["IMAGE"]
    project_name = config["PROJECT"]
    port = config.get("PORT", "8080")  # Default port if not specified
    
    # Get git info
    image_tag, branch = get_git_info()
    full_image = f"{DOCKER_ORG}/{image_name}:{image_tag}"
    
    # Print build info with dynamic box width
    PREFIX_LEN = 16  # Approx: " üê≥ Image      : "
    PADDING = 6
    
    content_lens = [len(full_image), len(PLATFORM), len(branch), len(BUILDER_NAME), len(project_name)]
    box_width = PREFIX_LEN + max(content_lens) + PADDING
    box_width = max(box_width, 50)  # Minimum width
    
    title = "Build Info"
    remaining = box_width - len(title) - 3  # -3 for "‚îÄ " before and " " after title
    
    print()
    print(f"{DIM}{Box.TL}{Box.H} {RESET}{BOLD}{title}{RESET}{DIM} {Box.H * remaining}{Box.TR}{RESET}")
    print(f" üê≥ Image      : {full_image}")
    print(f" üì¶ Project    : {project_name}")
    print(f" üîå Port       : {port}")
    print(f" üß± Platform   : {PLATFORM}")
    print(f" üåø Branch     : {branch}")
    print(f" üîß Builder    : {BUILDER_NAME}")
    print(f"{DIM}{Box.BL}{Box.H * box_width}{Box.BR}{RESET}")
    print()
    
    if info_only:
        print(f"{YELLOW}‚ÑπÔ∏è  Info only mode - no build{RESET}")
        return
    
    # Ensure builder
    ensure_builder(BUILDER_NAME)
    
    # Build & push
    run([
        "docker", "buildx", "build",
        "--platform", PLATFORM,
        "--no-cache",
        "--builder", BUILDER_NAME,
        "--build-arg", f"PROJECT={project_name}",
        "--build-arg", f"PORT={port}",
        "--build-arg", f"BRANCH={branch}",
        "--tag", full_image,
        "--attest", "type=sbom",
        "--attest", "type=provenance,mode=max",
        "--push",
        "."
    ])
    
    # Generate output JSON
    build_output = {
        "image": f"{DOCKER_ORG}/{image_name}",
        "tag": image_tag,
        "branch": branch
    }
    
    # Write to file
    output_file.write_text(json.dumps(build_output, indent=2))
    
    # Print result
    print()
    success("Image pushed successfully!")
    print()
    print(f"{GREEN}üìÑ Build Output ‚Üí {output_file}{RESET}")
    print(json.dumps(build_output, indent=2))


if __name__ == "__main__":
    try:
        main()
    except subprocess.CalledProcessError as e:
        error(f"Command failed: {' '.join(e.cmd)}")
    except KeyboardInterrupt:
        print(f"\n{YELLOW}‚ö† Build cancelled{RESET}")
        sys.exit(130)
    except Exception as e:
        error(str(e))
